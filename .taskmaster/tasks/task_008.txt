# Task ID: 8
# Title: 파일 다운로드 및 조회 API 구현
# Status: pending
# Dependencies: 7
# Priority: high
# Description: 파일 다운로드, 정보 조회, 미리보기 기능, 조회/다운로드 기록
# Details:
파일 다운로드 API:
```python
@router.get("/download/{file_uuid}")
async def download_file(file_uuid: str, request: Request):
    # 캐시에서 파일 정보 조회
    file_info = await cache_service.get_file_info(file_uuid)
    if not file_info:
        file_info = await db.query(FileInfo).filter(FileInfo.file_uuid == file_uuid).first()
        if file_info:
            await cache_service.set_file_info(file_uuid, file_info.dict())
    
    # 다운로드 기록 저장
    download_record = FileDownload(
        file_id=file_info.id,
        downloader_ip=request.client.host,
        download_method="api",
        session_id=request.headers.get("session-id")
    )
    
    # 파일 스트리밍 응답
    return StreamingResponse(
        file_generator(file_info.storage_path),
        media_type=file_info.mime_type,
        headers={"Content-Disposition": f"attachment; filename={file_info.original_filename}"}
    )
```
텍스트 파일 미리보기, 적절한 Content-Type 헤더 설정
<info added on 2025-07-25T07:41:23.534Z>
**새로운 DB 스키마 구조 기반 API 업데이트:**

파일 정보 조회 API:
```python
@router.get("/api/v1/files/{file_uuid}")
async def get_file_info(file_uuid: str, request: Request):
    # UUID 기반 파일 조회
    file_info = await db.query(FileInfo).filter(FileInfo.file_uuid == file_uuid).first()
    if not file_info:
        raise HTTPException(404, "파일을 찾을 수 없습니다")
    
    # 조회 기록 저장
    view_record = FileView(
        file_uuid=file_uuid,
        viewer_ip=request.client.host,
        user_agent=request.headers.get("user-agent"),
        view_type="info",
        session_id=request.headers.get("session-id")
    )
    db.add(view_record)
    
    # file_statistics 뷰에서 통계 정보 조회
    stats = await db.query(FileStatistics).filter(FileStatistics.file_uuid == file_uuid).first()
    
    return {
        "file_info": file_info.dict(),
        "statistics": stats.dict() if stats else None
    }
```

업데이트된 파일 다운로드 API:
```python
@router.get("/api/v1/files/{file_uuid}/download")
async def download_file(file_uuid: str, method: str = "direct", request: Request):
    # UUID 기반 파일 조회
    file_info = await db.query(FileInfo).filter(FileInfo.file_uuid == file_uuid).first()
    if not file_info:
        raise HTTPException(404, "파일을 찾을 수 없습니다")
    
    # 다운로드 기록 저장
    download_record = FileDownload(
        file_uuid=file_uuid,
        downloader_ip=request.client.host,
        download_method=method,
        bytes_downloaded=file_info.file_size,
        session_id=request.headers.get("session-id")
    )
    db.add(download_record)
    
    # 조회 기록도 함께 저장
    view_record = FileView(
        file_uuid=file_uuid,
        viewer_ip=request.client.host,
        user_agent=request.headers.get("user-agent"),
        view_type="download",
        session_id=request.headers.get("session-id")
    )
    db.add(view_record)
    
    return StreamingResponse(
        file_generator(file_info.storage_path),
        media_type=file_info.mime_type,
        headers={"Content-Disposition": f"attachment; filename={file_info.original_filename}"}
    )
```

파일 목록 조회 API (페이지네이션):
```python
@router.get("/api/v1/files")
async def list_files(
    category_id: Optional[int] = None,
    tags: Optional[List[str]] = Query(None),
    is_public: bool = True,
    page: int = 1,
    size: int = 20
):
    offset = (page - 1) * size
    query = db.query(FileInfo).filter(FileInfo.is_public == is_public)
    
    # 카테고리별 필터링
    if category_id:
        query = query.filter(FileInfo.category_id == category_id)
    
    # 태그 기반 필터링
    if tags:
        query = query.join(FileTagRelation).join(FileTag).filter(FileTag.tag_name.in_(tags))
    
    # 복합 인덱스 활용한 효율적인 쿼리
    files = query.offset(offset).limit(size).all()
    total = query.count()
    
    return {
        "files": [file.dict() for file in files],
        "pagination": {
            "page": page,
            "size": size,
            "total": total,
            "pages": (total + size - 1) // size
        }
    }
```

파일 검색 API:
```python
@router.get("/api/v1/files/search")
async def search_files(
    query: str,
    file_type: Optional[str] = None,
    date_from: Optional[datetime] = None,
    date_to: Optional[datetime] = None,
    page: int = 1,
    size: int = 20
):
    offset = (page - 1) * size
    search_query = db.query(FileInfo)
    
    # 파일명, 설명 기반 검색
    search_query = search_query.filter(
        or_(
            FileInfo.original_filename.contains(query),
            FileInfo.description.contains(query)
        )
    )
    
    # 확장자별 필터링
    if file_type:
        search_query = search_query.filter(FileInfo.file_extension == file_type)
    
    # 날짜 범위 필터링
    if date_from:
        search_query = search_query.filter(FileInfo.created_at >= date_from)
    if date_to:
        search_query = search_query.filter(FileInfo.created_at <= date_to)
    
    files = search_query.offset(offset).limit(size).all()
    total = search_query.count()
    
    return {
        "files": [file.dict() for file in files],
        "pagination": {
            "page": page,
            "size": size,
            "total": total,
            "pages": (total + size - 1) // size
        }
    }
```

**성능 최적화 구현:**
- file_statistics 뷰 활용으로 조인 연산 최소화
- 복합 인덱스 (file_uuid, is_public, category_id) 활용
- Redis 캐싱과 연동하여 반복 조회 최적화:
```python
# 캐시 키 전략
cache_key = f"file_info:{file_uuid}"
cached_info = await redis.get(cache_key)
if not cached_info:
    file_info = await db.query(FileInfo).filter(FileInfo.file_uuid == file_uuid).first()
    await redis.setex(cache_key, 3600, file_info.json())
```

**테이블 관계 활용:**
- file_tags와 file_tag_relations를 통한 태그 기반 검색
- file_categories 테이블을 통한 카테고리별 필터링
- file_views와 file_downloads 테이블을 통한 상세한 사용자 행동 추적
</info added on 2025-07-25T07:41:23.534Z>

# Test Strategy:
다양한 파일 타입 다운로드 테스트, 스트리밍 성능 검증, 조회 기록 저장 확인, 미리보기 기능 테스트, 동시 다운로드 처리
