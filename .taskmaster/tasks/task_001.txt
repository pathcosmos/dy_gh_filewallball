# Task ID: 1
# Title: MicroK8s 환경 설정 및 기본 인프라 구축
# Status: done
# Dependencies: None
# Priority: high
# Description: MicroK8s 클러스터 설정, 네임스페이스 생성, PersistentVolume 구성
# Details:
MicroK8s 설치 및 활성화: `microk8s enable dns storage ingress`
네임스페이스 생성: `kubectl create namespace filewallball`
PersistentVolume 설정:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: file-storage-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /data/filewallball
```
기본 RBAC 설정 및 서비스 계정 구성

# Test Strategy:
kubectl 명령어로 클러스터 상태 확인, PV 생성 및 바인딩 테스트, 네임스페이스 리소스 접근 권한 검증

# Subtasks:
## 1. MicroK8s 설치 및 기본 애드온 활성화 [done]
### Dependencies: None
### Description: MicroK8s 설치 후 DNS, Storage, Ingress 애드온을 활성화하고 클러스터 상태를 확인합니다
### Details:
Ubuntu 시스템에 MicroK8s 설치: `sudo snap install microk8s --classic`, 사용자 그룹 추가: `sudo usermod -a -G microk8s $USER`, 애드온 활성화: `microk8s enable dns storage ingress`, 클러스터 상태 확인: `microk8s status --wait-ready`, kubectl 별칭 설정: `alias kubectl='microk8s kubectl'`
<info added on 2025-07-25T06:31:15.557Z>
**작업 완료 상태 업데이트:**

✅ MicroK8s 설치 및 기본 애드온 활성화 완료

**완료된 작업:**
1. ✅ MicroK8s 설치 확인 - 이미 설치되어 있음 (/snap/bin/microk8s)
2. ✅ 클러스터 상태 확인 - microk8s is running
3. ✅ 필수 애드온 활성화 확인:
   - dns (CoreDNS) ✅
   - storage (hostpath-storage) ✅  
   - ingress (nginx-ingress) ✅
4. ✅ kubectl 별칭 설정 완료
5. ✅ 노드 상태 확인 - localhost Ready
6. ✅ 시스템 Pod 상태 확인 - 모든 Pod 정상 실행 중

**테스트 결과:**
- microk8s status: 모든 필수 애드온 활성화됨
- kubectl get nodes: 노드 Ready 상태 확인
- kubectl get pods -A: 모든 시스템 Pod 정상 작동 확인

**다음 단계:** 세부 작업 1.2 (네임스페이스 및 기본 리소스 쿼터 설정) 진행 준비 완료
</info added on 2025-07-25T06:31:15.557Z>

## 2. 네임스페이스 및 기본 리소스 쿼터 설정 [done]
### Dependencies: 1.1
### Description: filewallball 네임스페이스를 생성하고 리소스 쿼터 및 네트워크 정책을 설정합니다
### Details:
네임스페이스 생성: `kubectl create namespace filewallball`, ResourceQuota 설정: CPU 10코어, 메모리 20Gi, PVC 5개 제한, LimitRange 설정: 컨테이너당 기본/최대 리소스 제한, 네임스페이스 레이블 추가: `kubectl label namespace filewallball env=production`
<info added on 2025-07-25T06:35:28.609Z>
✅ 네임스페이스 및 기본 리소스 쿼터 설정 완료

**완료된 작업:**
1. ✅ filewallball 네임스페이스 생성: `kubectl create namespace filewallball`
2. ✅ 네임스페이스 레이블 추가: `kubectl label namespace filewallball env=production`
3. ✅ ResourceQuota 설정:
   - CPU: 10코어 요청, 20코어 제한
   - 메모리: 20Gi 요청, 40Gi 제한
   - PVC: 5개 제한
   - 서비스: 10개 제한
   - Pod: 20개 제한
4. ✅ LimitRange 설정:
   - 컨테이너 기본 요청: CPU 100m, 메모리 128Mi
   - 컨테이너 기본 제한: CPU 500m, 메모리 512Mi
5. ✅ 설정 검증:
   - kubectl describe namespace filewallball로 네임스페이스 확인
   - kubectl describe resourcequota로 쿼터 적용 확인
   - 테스트 Pod 생성/삭제로 리소스 제한 정상 작동 확인

**생성된 파일:**
- k8s/resource-quota.yaml
- k8s/limit-range.yaml

**다음 단계:** 세부 작업 1.3 (PersistentVolume 및 StorageClass 구성) 진행 준비 완료
</info added on 2025-07-25T06:35:28.609Z>

## 3. PersistentVolume 및 StorageClass 구성 [done]
### Dependencies: 1.1, 1.2
### Description: 파일 저장을 위한 PersistentVolume과 동적 프로비저닝을 위한 StorageClass를 설정합니다
### Details:
호스트 디렉토리 생성: `sudo mkdir -p /data/filewallball && sudo chmod 777 /data/filewallball`, PersistentVolume 생성: 10Gi 용량, ReadWriteOnce 모드, hostPath 타입, StorageClass 생성: microk8s-hostpath 프로비저너 사용, volumeBindingMode: WaitForFirstConsumer, PersistentVolumeClaim 템플릿 준비
<info added on 2025-07-25T06:44:46.201Z>
PersistentVolume 및 StorageClass 구성 완료

완료된 작업:
1. 호스트 디렉토리 생성: `/data/filewallball` (권한 777)
2. PersistentVolume 생성:
   - 용량: 10Gi
   - 접근 모드: ReadWriteOnce
   - 경로: /data/filewallball
   - StorageClass: microk8s-hostpath
3. PersistentVolumeClaim 생성:
   - 요청 용량: 5Gi
   - 네임스페이스: filewallball
4. 볼륨 바인딩 테스트:
   - PVC가 PV에 성공적으로 바인딩됨
   - 테스트 Pod에서 볼륨 마운트 확인
   - 파일 쓰기/읽기 테스트 성공
5. 호스트 디렉토리에서 파일 생성 확인

생성된 파일:
- k8s/persistent-volume.yaml
- k8s/persistent-volume-claim.yaml

테스트 결과:
- kubectl get pv: PV 생성 및 바인딩 확인
- kubectl get pvc: PVC 바인딩 상태 확인
- Pod에서 볼륨 마운트 및 파일 쓰기/읽기 테스트 성공
- 호스트 디렉토리에서 파일 생성 확인

다음 단계: 세부 작업 1.4 (RBAC 및 서비스 계정 구성) 진행 준비 완료
</info added on 2025-07-25T06:44:46.201Z>

## 4. RBAC 및 서비스 계정 구성 [done]
### Dependencies: 1.2
### Description: 애플리케이션별 서비스 계정을 생성하고 적절한 RBAC 권한을 설정합니다
### Details:
서비스 계정 생성: filewallball-api, mariadb, redis 각각 생성, Role 정의: ConfigMap/Secret 읽기, PVC 생성/삭제, Pod 조회 권한, RoleBinding 생성: 각 서비스 계정에 적절한 Role 바인딩, ClusterRole 생성: Ingress 리소스 관리 권한 (API 서비스용), 보안 정책: Pod Security Standards 적용
<info added on 2025-07-25T07:10:38.693Z>
✅ RBAC 및 서비스 계정 구성 완료

**완료된 작업:**
1. ✅ 서비스 계정 생성:
   - filewallball-api
   - mariadb
   - redis
2. ✅ Role 정의:
   - filewallball-api-role: ConfigMap/Secret 읽기, PVC 생성/삭제, Pod 조회 권한
   - mariadb-role: ConfigMap/Secret 읽기, PVC 조회, Pod 조회 권한
   - redis-role: ConfigMap/Secret 읽기, Pod 조회 권한
3. ✅ RoleBinding 생성:
   - filewallball-api-rolebinding
   - mariadb-rolebinding
   - redis-rolebinding
4. ✅ 권한 테스트:
   - filewallball-api 서비스 계정의 ConfigMap 읽기 권한 확인
   - filewallball-api 서비스 계정의 PVC 생성 권한 확인
   - 권한 없는 리소스 접근 시 거부 확인

**생성된 파일:**
- k8s/api-role.yaml
- k8s/mariadb-role.yaml
- k8s/redis-role.yaml
- k8s/api-rolebinding.yaml
- k8s/mariadb-rolebinding.yaml
- k8s/redis-rolebinding.yaml

**다음 단계:** 세부 작업 1.5 (모니터링 및 로깅 기초 설정) 진행 준비 완료
</info added on 2025-07-25T07:10:38.693Z>

## 5. 모니터링 및 로깅 기초 설정 [done]
### Dependencies: 1.1, 1.2
### Description: 기본적인 모니터링과 로깅을 위한 ConfigMap과 초기 설정을 구성합니다
### Details:
로그 수집 ConfigMap 생성: fluentd 또는 fluent-bit 설정 준비, 메트릭 수집 설정: Prometheus ServiceMonitor 템플릿 준비, 로그 레벨 ConfigMap: 각 애플리케이션별 로그 레벨 설정 (DEBUG/INFO/WARN/ERROR), 로그 저장 경로 설정: /var/log/filewallball 디렉토리 구조, kubectl logs 명령어 활용 가이드 문서화
<info added on 2025-07-25T07:14:17.838Z>
**완료 상태 업데이트:**

모든 모니터링 및 로깅 기초 설정이 성공적으로 완료되었습니다.

**구현된 ConfigMap 및 설정:**
- filewallball-logging-config: 애플리케이션별 로그 레벨 관리 (filewallball-api: INFO, mariadb: WARN, redis: INFO)
- filewallball-metrics-config: Prometheus ServiceMonitor 및 알림 규칙 (높은 에러율, 높은 지연시간 감지)
- filewallball-log-rotation: 일별 로테이션, 7일 보관 정책

**생성된 인프라 파일:**
- k8s/logging-config.yaml: 로그 수집 및 fluentd 설정
- k8s/metrics-config.yaml: 메트릭 수집 및 Prometheus 연동
- k8s/log-rotation.yaml: 로그 로테이션 정책
- docs/logging-guide.md: kubectl logs 활용 가이드

**설정된 로그 저장소:**
- 호스트 디렉토리: /var/log/filewallball/ (권한: 755)
- JSON 형식 로그 출력 (stdout), 에러 로그 (stderr) 분리

**로그 수집 파이프라인:**
- fluentd를 통한 JSON 파싱 및 Elasticsearch 연동 준비
- 애플리케이션별 로그 레벨 동적 조정 가능

작업 상태: 완료 (done)
</info added on 2025-07-25T07:14:17.838Z>

