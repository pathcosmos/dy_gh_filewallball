<context>
# Overview  
FileWallBall API System은 FastAPI 기반의 파일 업로드/조회/다운로드 시스템입니다. 사용자가 파일을 업로드하면 즉시 조회 및 다운로드 URL을 반환하여, 간편하고 효율적인 파일 공유 서비스를 제공합니다. MicroK8s 환경에서 구동되며, Horizontal Pod Autoscaler(HPA)를 통해 실시간 요청에 따른 자동 스케일링을 지원합니다.

이 시스템은 개발팀, 콘텐츠 크리에이터, 그리고 파일 공유가 필요한 모든 사용자를 대상으로 하며, 안정적이고 확장 가능한 파일 관리 솔루션을 제공합니다.

# Core Features  
## 1. 파일 업로드 시스템
- **기능**: 사용자가 파일을 업로드하면 고유 ID와 함께 조회/다운로드 URL을 즉시 반환
- **중요성**: 사용자가 업로드한 파일에 즉시 접근할 수 있어 사용자 경험이 향상됨
- **동작 방식**: UUID 기반 고유 파일 ID 생성, MariaDB에 메타데이터 저장, Redis 캐싱, PersistentVolume에 파일 저장

## 2. 파일 조회 및 다운로드
- **기능**: 파일 ID를 통해 파일 정보 조회, 실제 파일 다운로드, 텍스트 파일 미리보기
- **중요성**: 업로드된 파일에 대한 안전하고 편리한 접근 제공
- **동작 방식**: MariaDB에서 메타데이터 조회, Redis 캐싱, PersistentVolume에서 파일 읽기, 적절한 Content-Type 헤더 설정

## 3. 파일 관리 시스템
- **기능**: 파일 목록 조회, 파일 삭제, 페이지네이션 지원, 상세한 조회/다운로드 기록 관리
- **중요성**: 사용자가 업로드한 파일들을 체계적으로 관리할 수 있음
- **동작 방식**: MariaDB에서 파일 목록 조회, Redis 캐싱, 소프트 삭제 지원, 모든 조회/다운로드 기록 DB 저장

## 4. 자동 스케일링 시스템
- **기능**: CPU/메모리 사용률에 따른 자동 Pod 스케일링
- **중요성**: 트래픽 증가 시 자동으로 리소스를 확장하여 서비스 안정성 보장
- **동작 방식**: HPA를 통한 CPU 70%, 메모리 80% 임계값 기반 스케일링

## 5. 모니터링 및 메트릭
- **기능**: Prometheus 메트릭, 헬스체크, 실시간 모니터링, 상세한 DB 기반 통계
- **중요성**: 시스템 상태를 실시간으로 모니터링하여 문제를 사전에 감지
- **동작 방식**: 파일 업로드/다운로드 카운터, 업로드 시간 히스토그램, 헬스체크 엔드포인트, MariaDB 기반 상세 통계

## 6. 데이터베이스 기반 파일 관리 시스템
- **기능**: MariaDB 기반 상세한 파일 메타데이터 관리, 조회/다운로드 기록 추적, 확장자별 자동 분류
- **중요성**: 수많은 파일의 긴밀한 조회와 상세한 사용 패턴 분석 가능
- **동작 방식**: ACID 트랜잭션 기반 메타데이터 저장, 모든 조회/다운로드 기록 DB 저장, 확장자별 자동 카테고리 분류

# User Experience  
## 사용자 페르소나
- **개발자**: API를 통한 파일 관리 기능이 필요한 개발팀
- **콘텐츠 크리에이터**: 파일 공유가 필요한 콘텐츠 제작자
- **일반 사용자**: 간편한 파일 공유 서비스를 원하는 사용자

## 주요 사용자 플로우
1. **파일 업로드 플로우**: 파일 선택 → 업로드 → URL 받기 → 공유
2. **파일 다운로드 플로우**: URL 접근 → 파일 정보 확인 → 다운로드
3. **파일 관리 플로우**: 파일 목록 확인 → 파일 정보 조회 → 필요시 삭제

## UI/UX 고려사항
- RESTful API 설계로 다양한 클라이언트에서 접근 가능
- JSON 응답 형식으로 표준화된 데이터 교환
- 적절한 HTTP 상태 코드와 에러 메시지 제공
- CORS 설정으로 웹 브라우저에서 직접 접근 가능
</context>
<PRD>
# Technical Architecture  
## 시스템 컴포넌트
- **FastAPI 애플리케이션**: 메인 API 서버 (Python 3.11, FastAPI, Uvicorn)
- **MariaDB 서버**: 파일 메타데이터 및 상세 기록 저장 (ACID 트랜잭션)
- **Redis 서버**: 성능 최적화를 위한 캐싱 및 세션 관리
- **Kubernetes 클러스터**: MicroK8s 기반 컨테이너 오케스트레이션
- **PersistentVolume**: 파일 저장소 (10Gi)
- **Ingress Controller**: 외부 트래픽 라우팅
- **Horizontal Pod Autoscaler**: 자동 스케일링 관리

## 데이터 모델
```python
# 핵심 파일 정보
class FileInfo:
    id: int               # 내부 고유 ID
    file_uuid: str        # UUID 기반 외부 식별자
    original_filename: str # 원본 파일명
    stored_filename: str  # 저장된 파일명
    file_extension: str   # 파일 확장자
    mime_type: str        # MIME 타입
    file_size: int        # 파일 크기 (bytes)
    file_hash: str        # 파일 MD5 해시
    storage_path: str     # 파일 저장 경로
    file_category_id: int # 파일 카테고리 ID
    is_public: bool       # 공개 여부
    is_deleted: bool      # 삭제 여부 (소프트 삭제)
    created_at: datetime  # 등록 시각
    updated_at: datetime  # 수정 시각

# 조회 기록
class FileView:
    file_id: int          # 파일 ID
    viewer_ip: str        # 조회자 IP
    user_agent: str       # 사용자 에이전트
    view_type: str        # 조회 타입 (info, preview, download)
    session_id: str       # 세션 ID
    created_at: datetime  # 조회 시각

# 다운로드 기록
class FileDownload:
    file_id: int          # 파일 ID
    downloader_ip: str    # 다운로더 IP
    download_method: str  # 다운로드 방법 (direct, api, web)
    bytes_downloaded: int # 다운로드된 바이트 수
    download_duration_ms: int # 다운로드 소요 시간
    session_id: str       # 세션 ID
    created_at: datetime  # 다운로드 시각
```

## API 엔드포인트
- `POST /upload` - 파일 업로드
- `GET /files/{file_id}` - 파일 정보 조회
- `GET /download/{file_id}` - 파일 다운로드
- `GET /view/{file_id}` - 파일 미리보기
- `GET /files` - 파일 목록 조회
- `DELETE /files/{file_id}` - 파일 삭제
- `GET /health` - 헬스체크
- `GET /metrics` - Prometheus 메트릭

## 인프라 요구사항
- **네임스페이스**: filewallball
- **Pod 리소스**: CPU 100m-200m, 메모리 128Mi-256Mi
- **스토리지**: 10Gi PersistentVolume (파일 저장용), 10Gi MariaDB PVC
- **네트워킹**: ClusterIP, LoadBalancer 서비스
- **스케일링**: 최소 2개, 최대 10개 Pod
- **데이터베이스**: MariaDB 10.11 (ACID 트랜잭션 지원)

# Development Roadmap  
## Phase 1: MVP (Minimum Viable Product)
### 핵심 기능 구현
- FastAPI 애플리케이션 기본 구조 구축
- 파일 업로드/다운로드 API 구현
- MariaDB 통합 및 메타데이터 저장
- Redis 캐싱 시스템 구축
- 기본 에러 처리 및 검증
- Docker 컨테이너화

### Kubernetes 배포
- MicroK8s 환경 설정
- MariaDB Deployment 및 Service 구성
- Redis Deployment 및 Service 구성
- 기본 Deployment 및 Service 구성
- PersistentVolume 설정 (파일 저장용, DB 저장용)
- 헬스체크 및 라이브니스 프로브 구현

## Phase 2: 확장성 및 안정성
### 자동 스케일링 구현
- Horizontal Pod Autoscaler 설정
- CPU/메모리 메트릭 수집
- 스케일링 정책 최적화
- 성능 모니터링 시스템 구축

### 고급 기능 추가
- 파일 미리보기 기능 (텍스트 파일)
- 파일 목록 조회 및 페이지네이션
- 파일 삭제 기능 (소프트 삭제)
- 상세한 조회/다운로드 기록 관리
- 확장자별 자동 카테고리 분류
- 보안 헤더 및 CORS 설정

## Phase 3: 모니터링 및 운영
### 모니터링 시스템
- Prometheus 메트릭 구현
- 로깅 시스템 개선
- 알림 시스템 구축
- 성능 대시보드 개발

### 운영 최적화
- 백업 및 복구 시스템
- 로그 로테이션
- 리소스 사용량 최적화
- 보안 강화

## Phase 4: 고급 기능
### 사용자 인증
- JWT 기반 인증 시스템
- 사용자별 파일 관리
- 권한 기반 접근 제어

### 고급 파일 관리
- 파일 암호화 기능
- CDN 통합
- 파일 버전 관리
- 대용량 파일 처리 최적화

# Logical Dependency Chain
## 1단계: 기반 인프라 구축
1. **MicroK8s 환경 설정** - 클러스터 준비
2. **네임스페이스 및 기본 리소스** - 격리된 환경 구성
3. **MariaDB 배포** - 메인 데이터베이스 시스템 구축
4. **Redis 배포** - 캐싱 시스템 구축
5. **PersistentVolume 설정** - 파일 저장소 및 DB 저장소 준비

## 2단계: 핵심 API 개발
1. **FastAPI 애플리케이션 구조** - 기본 프레임워크 구축
2. **MariaDB 통합** - 메타데이터 저장 및 조회 구현
3. **파일 업로드 API** - 가장 중요한 기능 구현
4. **Redis 캐싱 통합** - 성능 최적화 구현
5. **파일 다운로드 API** - 업로드와 쌍을 이루는 핵심 기능
6. **조회/다운로드 기록 시스템** - 상세한 사용 패턴 추적

## 3단계: 배포 및 테스트
1. **Docker 컨테이너화** - 배포 가능한 형태로 패키징
2. **Kubernetes 배포** - 실제 환경에서 실행
3. **기본 테스트** - 핵심 기능 검증
4. **헬스체크 구현** - 시스템 상태 모니터링

## 4단계: 확장성 구현
1. **HPA 설정** - 자동 스케일링 구현
2. **모니터링 메트릭** - 성능 측정 시스템
3. **고급 API 기능** - 파일 조회, 삭제, 미리보기
4. **데이터베이스 최적화** - 인덱스, 쿼리 최적화
5. **통계 및 분석 기능** - 사용 패턴 분석
6. **보안 강화** - CORS, 헤더, 검증

## 5단계: 운영 최적화
1. **로깅 시스템** - 문제 추적 및 디버깅
2. **데이터베이스 백업 시스템** - MariaDB 데이터 보호
3. **성능 최적화** - 리소스 사용량 개선
4. **데이터 정리 정책** - 오래된 파일 및 로그 정리
5. **보안 감사** - 취약점 점검 및 수정

# Risks and Mitigations  
## 기술적 도전 과제
### 1. 대용량 파일 처리
- **위험**: 대용량 파일 업로드 시 메모리 부족
- **완화책**: 스트리밍 업로드 구현, 청크 단위 처리, 파일 크기 제한

### 2. MariaDB 연결 안정성
- **위험**: MariaDB 서버 장애 시 메타데이터 손실
- **완화책**: MariaDB 클러스터 구성, 데이터 백업, 장애 복구 메커니즘, ACID 트랜잭션 보장

### 3. Redis 캐싱 안정성
- **위험**: Redis 서버 장애 시 캐시 손실
- **완화책**: Redis 클러스터 구성, 캐시 백업, 장애 복구 메커니즘

### 4. 스토리지 용량 관리
- **위험**: PersistentVolume 용량 초과
- **완화책**: 자동 정리 정책, TTL 기반 파일 삭제, 스토리지 모니터링

### 5. 데이터베이스 성능
- **위험**: 대용량 데이터로 인한 쿼리 성능 저하
- **완화책**: 인덱스 최적화, 쿼리 튜닝, 파티셔닝, 정기적인 통계 업데이트

### 6. 자동 스케일링 지연
- **위험**: 트래픽 급증 시 스케일링 지연으로 서비스 중단
- **완화책**: 사전 스케일링 정책, 리소스 예약, 모니터링 강화

## MVP 범위 정의
### 포함 기능
- 기본 파일 업로드/다운로드
- MariaDB 메타데이터 저장
- Redis 캐싱 시스템
- 상세한 조회/다운로드 기록
- 확장자별 자동 분류
- Kubernetes 배포
- 기본 헬스체크

### 제외 기능 (후속 단계)
- 사용자 인증
- 파일 암호화
- CDN 통합
- 고급 모니터링
- 고급 통계 및 분석

## 리소스 제약
### 개발 리소스
- **위험**: 개발 시간 부족
- **완화책**: 우선순위 기반 개발, 점진적 기능 구현

### 인프라 리소스
- **위험**: MicroK8s 리소스 부족
- **완화책**: 리소스 모니터링, 최적화, 필요시 클러스터 확장

# Appendix  
## 기술 스펙
### 개발 환경
- **언어**: Python 3.11
- **프레임워크**: FastAPI 0.104.1
- **서버**: Uvicorn
- **데이터베이스**: MariaDB 10.11
- **캐시**: Redis 7
- **ORM**: SQLAlchemy 2.0.23
- **컨테이너**: Docker
- **오케스트레이션**: Kubernetes (MicroK8s)

### 성능 요구사항
- **응답 시간**: API 응답 < 500ms
- **동시 사용자**: 100명 동시 접속 지원
- **파일 크기**: 최대 100MB
- **가용성**: 99.9% uptime

### 보안 요구사항
- **파일 검증**: 업로드 파일 타입 및 크기 검증
- **CORS 설정**: 적절한 도메인 허용
- **에러 처리**: 민감한 정보 노출 방지
- **로깅**: 보안 이벤트 기록

## 연구 결과
### 기술 선택 근거
- **FastAPI**: 높은 성능, 자동 문서화, 타입 힌트 지원
- **Redis**: 빠른 캐싱, 메모리 기반 성능
- **Kubernetes**: 확장성, 자동화, 표준화
- **MicroK8s**: 개발 환경 친화적, 가벼운 설치

### 아키텍처 패턴
- **RESTful API**: 표준 HTTP 메서드 사용
- **마이크로서비스**: 독립적인 서비스 구성
- **이벤트 기반**: 비동기 처리로 성능 최적화
- **하이브리드 저장소**: MariaDB (메인 DB) + Redis (캐시)
- **ACID 트랜잭션**: 데이터 일관성 보장
- **소프트 삭제**: 데이터 보존 및 복구 가능 